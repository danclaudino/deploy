<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Operators - AIDE-QC</title><meta name=description content="Advancing Integrated Development Environments for Quantum Computing"><meta name=generator content="Hugo 0.76.5"><link href=https://aide-qc.github.io/deployindex.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://aide-qc.github.io/deploy/users/operators/><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://aide-qc.github.io/deploy/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://aide-qc.github.io/deploy/aide_qc_logo_v3.png width=40px align=absmiddle>
AIDE-QC</div></h1><p class=description>Advancing Integrated Development Environments for Quantum Computing</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://aideqc.slack.com>AIDE-QC Slack</a></li><li class=child><a href=https://xacc-dev.slack.com>XACC/QCOR Slack</a></li></ul></li><li class=parent><a href=https://github.com/aide-qc>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://ornl-qci.github.io/qcor-api-docs/>QCOR Doxygen</a></li><li class=child><a href=https://ornl-qci.github.io/xacc-api-docs/>XACC Doxygen</a></li><li class=child><a href=https://github.com/aide-qc/qcor>QCOR</a></li><li class=child><a href=https://github.com/aide-qc/xacc>XACC</a></li></ul></li><li><a href=https://github.com/aide-qc/aide-qc/issues>Bugs</a></li><li><a href=http://aide-qc.org>Project Page</a></li></ul></nav></div><div class=content-container><main><h1>Operators</h1><p>The AIDE-QC stack puts forward as part of the QCOR specification an extensible
model for quantum mechanical operators.</p><p>We sub-type this concept for operators exposing a certain algebra. We have defined <code>PauliOperator</code> and <code>FermionOperator</code> sub-types, and have put forward a mechanism for transformation between the two.</p><h2 id=a-idspina-spin-operators><a id=spin></a>Spin Operators&nbsp;<a class=headline-hash href=#a-idspina-spin-operators>¶</a></h2><p>AIDE-QC puts forward an <code>Operator</code> implementation to model Pauli matrices, Pauli tensor products, and sums of Pauli tensor products. The <code>PauliOperator</code> can be create in C++ and Python and used in the familiar algebraic name. We expose <code>X(int)</code>, <code>Y(int)</code>, and <code>Z(int)</code> API calls that return the corresponding Pauli operator on the provide qubit index. These can be used to build up more compilicated Pauli operators:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>auto</span> <span class=n>H</span> <span class=o>=</span> <span class=mf>5.907</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mf>.21829</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span>
           <span class=mf>6.125</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</code></pre></div><p>Note here that algebraic operators are defined on this data structure, so composing simple Pauli matrices into larger tensorial product terms and summing them is extremely straightforward. These operators can also be created from string</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>auto</span> <span class=n>H</span> <span class=o>=</span> <span class=n>createOperator</span><span class=p>(</span>
      <span class=s>&#34;5.907 - 2.1433 X0X1 - 2.1433 Y0Y1 + .21829 Z0 - 6.125 Z1&#34;</span><span class=p>);</span>
</code></pre></div><p>And note, these API calls are also in Python</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span>
<span class=n>H</span> <span class=o>=</span> <span class=o>-</span><span class=mf>2.1433</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mf>2.1433</span> <span class=o>*</span> \
    <span class=n>Y</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Y</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=o>.</span><span class=mi>21829</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>-</span> <span class=mf>6.125</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mf>5.907</span>
<span class=n>H</span> <span class=o>=</span> <span class=n>createOperator</span><span class=p>(</span>
      <span class=s2>&#34;5.907 - 2.1433 X0X1 - 2.1433 Y0Y1 + .21829 Z0 - 6.125 Z1&#34;</span><span class=p>)</span>
</code></pre></div><p>Time-dependent Hamiltonians can be defined using these API calls:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>td_hamiltonian</span><span class=p>(</span><span class=n>t</span><span class=p>):</span>
  <span class=n>Jz</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=mf>2.86265</span> <span class=o>*</span> <span class=mf>1e-3</span>
  <span class=n>epsilon</span> <span class=o>=</span> <span class=n>Jz</span>
  <span class=n>omega</span> <span class=o>=</span> <span class=mf>4.8</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=mf>1e-3</span>
  <span class=k>return</span> <span class=o>-</span><span class=n>Jz</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=o>-</span> <span class=n>Jz</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>Z</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=o>-</span><span class=n>epsilon</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>cos</span><span class=p>(</span><span class=n>omega</span> <span class=o>*</span> <span class=n>t</span><span class=p>))</span> <span class=o>*</span> <span class=p>(</span><span class=n>X</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>X</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>X</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span> 
</code></pre></div><h2 id=a-idfermiona-fermion-operators><a id=fermion></a>Fermion Operators&nbsp;<a class=headline-hash href=#a-idfermiona-fermion-operators>¶</a></h2><p>AIDE-QC puts forward an <code>Operator</code> implementation to model fermion operators. These can be constructed from
exposed <code>adag(int)</code> and <code>a(int)</code> API calls representing fermion creation and annhilation operators, respectively. The instance returned from these API calls exposes appropriate algebra and can be used to construct more complicated fermionic tensor product terms.</p><p>TODO finish this&mldr;</p><h2 id=a-idchemistrya-chemistry-operators><a id=chemistry></a>Chemistry Operators&nbsp;<a class=headline-hash href=#a-idchemistrya-chemistry-operators>¶</a></h2><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>H</span> <span class=o>=</span> <span class=n>createOperator</span><span class=p>(</span><span class=s1>&#39;psi4&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;geometry&#39;</span><span class=p>:</span><span class=n>geom_str</span><span class=p>,</span> <span class=s1>&#39;basis&#39;</span><span class=p>:</span><span class=s1>&#39;sto-3g&#39;</span><span class=p>})</span>
<span class=o>-</span><span class=ow>or</span><span class=o>-</span>
<span class=n>H</span> <span class=o>=</span> <span class=n>createOperator</span><span class=p>(</span><span class=s1>&#39;pyscf&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;geometry&#39;</span><span class=p>:</span><span class=n>geom_str</span><span class=p>,</span> <span class=s1>&#39;basis&#39;</span><span class=p>:</span><span class=s1>&#39;sto-3g&#39;</span><span class=p>})</span>
</code></pre></div><h2 id=a-idopenfermiona-openfermion-integration><a id=openfermion></a>OpenFermion Integration&nbsp;<a class=headline-hash href=#a-idopenfermiona-openfermion-integration>¶</a></h2><p>The AIDE-QC Python API is fully interoperable with
<a href=https://openfermion.org>OpenFermion</a>
. Programmers can provide a <code>FermionOperator</code> or a <code>QubitOperator</code> anywhere in the API where a QCOR <code>Operator</code> is an input argument. See the example below</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span>
<span class=kn>from</span> <span class=nn>openfermion.ops</span> <span class=kn>import</span> <span class=n>FermionOperator</span> <span class=k>as</span> <span class=n>FOp</span>

<span class=c1># Create Operator as an OpenFermion FermionOperator</span>
<span class=n>H</span> <span class=o>=</span> <span class=n>FOp</span><span class=p>(</span><span class=s1>&#39;&#39;</span><span class=p>,</span> <span class=mf>0.0002899</span><span class=p>)</span> <span class=o>+</span> <span class=n>FOp</span><span class=p>(</span><span class=s1>&#39;0^ 0&#39;</span><span class=p>,</span> <span class=o>-.</span><span class=mi>43658</span><span class=p>)</span> <span class=o>+</span> \
    <span class=n>FOp</span><span class=p>(</span><span class=s1>&#39;1 0^&#39;</span><span class=p>,</span> <span class=mf>4.2866</span><span class=p>)</span> <span class=o>+</span> <span class=n>FOp</span><span class=p>(</span><span class=s1>&#39;1^ 0&#39;</span><span class=p>,</span> <span class=o>-</span><span class=mf>4.2866</span><span class=p>)</span> <span class=o>+</span> <span class=n>FOp</span><span class=p>(</span><span class=s1>&#39;1^ 1&#39;</span><span class=p>,</span> <span class=mf>12.25</span><span class=p>)</span> 

<span class=c1># Could also have used Qubit Operator, or transform result</span>
<span class=c1># H = jordan_wigner(...FermionOp...) </span>
<span class=c1># H = QOp(&#39;&#39;, 5.907) + QOp(&#39;Y0 Y1&#39;, -2.1433) + \</span>
<span class=c1>#      QOp(&#39;X0 X1&#39;, -2.1433) + QOp(&#39;Z0&#39;, .21829) + QOp(&#39;Z1&#39;, -6.125) </span>

<span class=c1># Define the quantum kernel              </span>
<span class=nd>@qjit</span>
<span class=k>def</span> <span class=nf>ansatz</span><span class=p>(</span><span class=n>q</span><span class=p>:</span> <span class=n>qreg</span><span class=p>,</span> <span class=n>theta</span><span class=p>:</span> <span class=nb>float</span><span class=p>):</span>
      <span class=n>X</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
      <span class=n>Ry</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>theta</span><span class=p>)</span>
      <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>

<span class=c1># Create the ObjectiveFunction, providing the FermionOperator as the Observable</span>
<span class=n>n_params</span> <span class=o>=</span> <span class=mi>1</span>
<span class=n>obj</span> <span class=o>=</span> <span class=n>createObjectiveFunction</span><span class=p>(</span><span class=n>ansatz</span><span class=p>,</span> <span class=n>H</span><span class=p>,</span> 
            <span class=n>n_params</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;gradient-strategy&#39;</span><span class=p>:</span><span class=s1>&#39;parameter-shift&#39;</span><span class=p>})</span>

<span class=c1># Optimize!</span>
<span class=n>optimizer</span> <span class=o>=</span> <span class=n>createOptimizer</span><span class=p>(</span><span class=s1>&#39;nlopt&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;nlopt-optimizer&#39;</span><span class=p>:</span><span class=s1>&#39;l-bfgs&#39;</span><span class=p>})</span>
<span class=n>results</span> <span class=o>=</span> <span class=n>optimizer</span><span class=o>.</span><span class=n>optimize</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span>
</code></pre></div><h2 id=a-idtransformsa-operator-transformations><a id=transforms></a>Operator Transformations&nbsp;<a class=headline-hash href=#a-idtransformsa-operator-transformations>¶</a></h2><p>The AIDE-QC stack defines an extension point for injecting general transformations on <code>Operators</code>. We leverage this for
ubiquitous lowering operators (e.g. Fermion to Pauli/Spin), but also for transformations that reduce or
simplify <code>Operators</code> in some iso-morphic way. Using these transformations is straightforward - here we demonstrate
how to transform an <code>Operator</code> representing the 4-qubit molecular hydrogen Hamiltonian to a simpler 1-qubit form
through the application of discrete <code>Z_2</code> symmetries (from this
<a href=https://arxiv.org/abs/1701.08213>paper</a>
).</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span>

<span class=c1># Create the Hamiltonian using the PySCF Operator plugin</span>
<span class=n>H</span> <span class=o>=</span> <span class=n>createOperator</span><span class=p>(</span><span class=s1>&#39;pyscf&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;basis&#39;</span><span class=p>:</span> <span class=s1>&#39;sto-3g&#39;</span><span class=p>,</span> <span class=s1>&#39;geometry&#39;</span><span class=p>:</span> <span class=s1>&#39;H  0.000000   0.0      0.0</span><span class=se>\n</span><span class=s1>H   0.0        0.0  .7474&#39;</span><span class=p>})</span>
<span class=k>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>Original:</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>H</span><span class=o>.</span><span class=n>toString</span><span class=p>())</span>

<span class=c1># Transform it with the qubit-tapering Operator Transform</span>
<span class=n>H_tapered</span> <span class=o>=</span> <span class=n>operatorTransform</span><span class=p>(</span><span class=s1>&#39;qubit-tapering&#39;</span><span class=p>,</span> <span class=n>H</span><span class=p>)</span>

<span class=c1># See the result</span>
<span class=k>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>Tapered:</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>H_tapered</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>python3 test_op_transforms.py

Original:
 <span class=o>(</span>0.0454063,0<span class=o>)</span> 2^ 0^ <span class=m>1</span> <span class=m>3</span> + <span class=o>(</span>0.0454063,0<span class=o>)</span> 1^ 2^ <span class=m>3</span> <span class=m>0</span> + <span class=o>(</span>0.168336,0<span class=o>)</span> 2^ 0^ <span class=m>0</span> <span class=m>2</span> + <span class=o>(</span>0.1202,0<span class=o>)</span> 1^ 0^ <span class=m>0</span> <span class=m>1</span> + <span class=o>(</span>0.174073,0<span class=o>)</span> 1^ 3^ <span class=m>3</span> <span class=m>1</span> + <span class=o>(</span>-0.174073,-0<span class=o>)</span> 1^ 3^ <span class=m>1</span> <span class=m>3</span> + <span class=o>(</span>-0.0454063,-0<span class=o>)</span> 3^ 0^ <span class=m>2</span> <span class=m>1</span> + <span class=o>(</span>-0.0454063,-0<span class=o>)</span> 2^ 0^ <span class=m>3</span> <span class=m>1</span> + <span class=o>(</span>-0.0454063,-0<span class=o>)</span> 1^ 2^ <span class=m>0</span> <span class=m>3</span> + <span class=o>(</span>-0.168336,-0<span class=o>)</span> 2^ 0^ <span class=m>2</span> <span class=m>0</span> + <span class=o>(</span>-0.1202,-0<span class=o>)</span> 2^ 3^ <span class=m>2</span> <span class=m>3</span> + <span class=o>(</span>-0.0454063,-0<span class=o>)</span> 3^ 1^ <span class=m>2</span> <span class=m>0</span> + <span class=o>(</span>-0.165607,-0<span class=o>)</span> 1^ 2^ <span class=m>1</span> <span class=m>2</span> + <span class=o>(</span>0.165607,0<span class=o>)</span> 0^ 3^ <span class=m>3</span> <span class=m>0</span> + <span class=o>(</span>-0.1202,-0<span class=o>)</span> 0^ 1^ <span class=m>0</span> <span class=m>1</span> + <span class=o>(</span>0.0454063,0<span class=o>)</span> 3^ 1^ <span class=m>0</span> <span class=m>2</span> + <span class=o>(</span>0.165607,0<span class=o>)</span> 1^ 2^ <span class=m>2</span> <span class=m>1</span> + <span class=o>(</span>0.165607,0<span class=o>)</span> 2^ 1^ <span class=m>1</span> <span class=m>2</span> + <span class=o>(</span>0.0454063,0<span class=o>)</span> 1^ 3^ <span class=m>2</span> <span class=m>0</span> + <span class=o>(</span>-0.0454063,-0<span class=o>)</span> 0^ 3^ <span class=m>1</span> <span class=m>2</span> + <span class=o>(</span>-0.1202,-0<span class=o>)</span> 3^ 2^ <span class=m>3</span> <span class=m>2</span> + <span class=o>(</span>-0.0454063,-0<span class=o>)</span> 2^ 1^ <span class=m>3</span> <span class=m>0</span> + <span class=o>(</span>-0.174073,-0<span class=o>)</span> 3^ 1^ <span class=m>3</span> <span class=m>1</span> + <span class=o>(</span>0.1202,0<span class=o>)</span> 2^ 3^ <span class=m>3</span> <span class=m>2</span> + <span class=o>(</span>0.0454063,0<span class=o>)</span> 3^ 0^ <span class=m>1</span> <span class=m>2</span> + <span class=o>(</span>-0.165607,-0<span class=o>)</span> 3^ 0^ <span class=m>3</span> <span class=m>0</span> + <span class=o>(</span>0.165607,0<span class=o>)</span> 3^ 0^ <span class=m>0</span> <span class=m>3</span> + <span class=o>(</span>0.174073,0<span class=o>)</span> 3^ 1^ <span class=m>1</span> <span class=m>3</span> + <span class=o>(</span>0.1202,0<span class=o>)</span> 3^ 2^ <span class=m>2</span> <span class=m>3</span> + <span class=o>(</span>0.0454063,0<span class=o>)</span> 0^ 2^ <span class=m>3</span> <span class=m>1</span> + <span class=o>(</span>0.168336,0<span class=o>)</span> 0^ 2^ <span class=m>2</span> <span class=m>0</span> + <span class=o>(</span>0.1202,0<span class=o>)</span> 0^ 1^ <span class=m>1</span> <span class=m>0</span> + <span class=o>(</span>-0.0454063,-0<span class=o>)</span> 0^ 2^ <span class=m>1</span> <span class=m>3</span> + <span class=o>(</span>-0.165607,-0<span class=o>)</span> 2^ 1^ <span class=m>2</span> <span class=m>1</span> + <span class=o>(</span>-0.165607,-0<span class=o>)</span> 0^ 3^ <span class=m>0</span> <span class=m>3</span> + <span class=o>(</span>-0.1202,-0<span class=o>)</span> 1^ 0^ <span class=m>1</span> <span class=m>0</span> + <span class=o>(</span>-0.168336,-0<span class=o>)</span> 0^ 2^ <span class=m>0</span> <span class=m>2</span> + <span class=o>(</span>0.0454063,0<span class=o>)</span> 2^ 1^ <span class=m>0</span> <span class=m>3</span> + <span class=o>(</span>-0.479678,-0<span class=o>)</span> 3^ <span class=m>3</span> + <span class=o>(</span>-1.24885,-0<span class=o>)</span> 0^ <span class=m>0</span> + <span class=o>(</span>-0.479678,-0<span class=o>)</span> 1^ <span class=m>1</span> + <span class=o>(</span>0.708024,0<span class=o>)</span> + <span class=o>(</span>0.0454063,0<span class=o>)</span> 0^ 3^ <span class=m>2</span> <span class=m>1</span> + <span class=o>(</span>-0.0454063,-0<span class=o>)</span> 1^ 3^ <span class=m>0</span> <span class=m>2</span> + <span class=o>(</span>-1.24885,-0<span class=o>)</span> 2^ <span class=m>2</span>

Tapered:
 <span class=o>(</span>-0.780646,0<span class=o>)</span> Z0 + <span class=o>(</span>-0.335686,0<span class=o>)</span> + <span class=o>(</span>0.181625,0<span class=o>)</span> X0
</code></pre></div><p>And of course we can leverage this new tapered Hamiltonian in any of the existing algorithms we support:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=o>*</span>

<span class=c1># Create the Hamiltonian using the PySCF Operator plugin</span>
<span class=c1># and reduce it with qubit-tapering</span>
<span class=n>H</span> <span class=o>=</span> <span class=n>createOperator</span><span class=p>(</span><span class=s1>&#39;pyscf&#39;</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;basis&#39;</span><span class=p>:</span> <span class=s1>&#39;sto-3g&#39;</span><span class=p>,</span> <span class=s1>&#39;geometry&#39;</span><span class=p>:</span> <span class=s1>&#39;H  0.000000   0.0      0.0</span><span class=se>\n</span><span class=s1>H   0.0        0.0  .7474&#39;</span><span class=p>})</span>
<span class=n>H_tapered</span> <span class=o>=</span> <span class=n>operatorTransform</span><span class=p>(</span><span class=s1>&#39;qubit-tapering&#39;</span><span class=p>,</span> <span class=n>H</span><span class=p>)</span>

<span class=c1># Define a 1-qubit ansatz, just move around the bloch sphere</span>
<span class=nd>@qjit</span>
<span class=k>def</span> <span class=nf>ansatz</span><span class=p>(</span><span class=n>q</span> <span class=p>:</span> <span class=n>qreg</span><span class=p>,</span> <span class=n>x</span> <span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>float</span><span class=p>]):</span>
    <span class=n>Rx</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=n>Ry</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>

<span class=c1># Create the problem model, provide the state </span>
<span class=c1># prep circuit, Hamiltonian and note how many variational parameters </span>
<span class=n>num_params</span> <span class=o>=</span> <span class=mi>2</span>
<span class=n>problemModel</span> <span class=o>=</span> <span class=n>qsim</span><span class=o>.</span><span class=n>ModelBuilder</span><span class=o>.</span><span class=n>createModel</span><span class=p>(</span><span class=n>ansatz</span><span class=p>,</span> <span class=n>H_tapered</span><span class=p>,</span> <span class=n>num_params</span><span class=p>)</span>

<span class=c1># Create the VQE workflow</span>
<span class=n>workflow</span> <span class=o>=</span> <span class=n>qsim</span><span class=o>.</span><span class=n>getWorkflow</span><span class=p>(</span><span class=s1>&#39;vqe&#39;</span><span class=p>)</span>

<span class=c1># Execute and print the result</span>
<span class=n>result</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>problemModel</span><span class=p>)</span>
<span class=n>energy</span> <span class=o>=</span> <span class=n>result</span><span class=p>[</span><span class=s1>&#39;energy&#39;</span><span class=p>]</span>
<span class=k>print</span><span class=p>(</span><span class=s1>&#39;VQE Energy = &#39;</span><span class=p>,</span> <span class=n>energy</span><span class=p>)</span>
</code></pre></div><div class=edit-meta><br><a href=https://github.com/aide-qc/deploy//edit/master/website/content/users/operators.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/deploy/users/hello_world/ title="Hello World"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Hello World</a>
<a class="nav nav-next" href=/deploy/users/pass_manager/ title="Pass Manager">Next - Pass Manager <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://aide-qc.github.io/deploy>Home</a></li><li class=has-sub-menu><a href=/deploy/background/>Background<span class="mark closed">+</span></a><ul class=sub-menu></ul></li><li class=has-sub-menu><a href=/deploy/developers/>Developer Guide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/developers/implement_optimizer/>Implement a new Optimizer</a></li><li><a href=/deploy/developers/clang_syntax/>QCOR Clang Syntax Handler</a></li></ul></li><li class=has-sub-menu><a href=/deploy/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/getting_started/Faq/>Frequently Asked Questions</a></li><li><a href=/deploy/getting_started/build_from_source/>Build Everything from Source</a></li></ul></li><li class="parent has-sub-menu"><a href=/deploy/users/>User Guide<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/deploy/users/hello_world/>Hello World</a></li><li class=active><a href=/deploy/users/operators/>Operators</a></li><li><a href=/deploy/users/pass_manager/>Pass Manager</a></li><li><a href=/deploy/users/qjit/>Quantum JIT (QJIT)</a></li><li><a href=/deploy/users/quantum_kernels/>Quantum Kernels</a></li><li><a href=/deploy/users/remote_qpu_creds/>Remote QPU Credentials</a></li><li><a href=/deploy/users/tnqvm/>Tensor Network Quantum Virtual Machine</a></li><li><a href=/deploy/users/using_optimizer/>Using an Optimizer</a></li><li><a href=/deploy/users/variational/>Variational Algorithms</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>